<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Kinematics/dynamics algorithms · RigidBodyDynamics.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RigidBodyDynamics.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../generated/1. Quickstart - double pendulum/1. Quickstart - double pendulum/">1. Quickstart - double pendulum</a></li><li><a class="tocitem" href="../generated/2. Closed-loop simulation and visualization/2. Closed-loop simulation and visualization/">2. Closed-loop simulation and visualization</a></li><li><a class="tocitem" href="../generated/3. Four-bar linkage/3. Four-bar linkage/">3. Four-bar linkage</a></li><li><a class="tocitem" href="../generated/4. Jacobian IK and Control/4. Jacobian IK and Control/">4. Jacobian IK and Control</a></li><li><a class="tocitem" href="../generated/5. Derivatives and gradients using ForwardDiff/5. Derivatives and gradients using ForwardDiff/">5. Derivatives and gradients using ForwardDiff</a></li><li><a class="tocitem" href="../generated/6. Symbolics using SymPy/6. Symbolics using SymPy/">6. Symbolics using SymPy</a></li><li><a class="tocitem" href="../generated/7. Rigorous error bounds using IntervalArithmetic/7. Rigorous error bounds using IntervalArithmetic/">7. Rigorous error bounds using IntervalArithmetic</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../spatial/">Spatial vector algebra</a></li><li><a class="tocitem" href="../joints/">Joints</a></li><li><a class="tocitem" href="../rigidbody/">Rigid bodies</a></li><li><a class="tocitem" href="../mechanism/">Mechanism</a></li><li><a class="tocitem" href="../mechanismstate/">MechanismState</a></li><li class="is-active"><a class="tocitem" href>Kinematics/dynamics algorithms</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#The-DynamicsResult-type"><span>The <code>DynamicsResult</code> type</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li><li><a class="tocitem" href="../customcollections/">Custom collection types</a></li><li><a class="tocitem" href="../caches/">Cache types</a></li><li><a class="tocitem" href="../simulation/">Simulation</a></li><li><a class="tocitem" href="../urdf/">URDF parsing and writing</a></li></ul></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Kinematics/dynamics algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Kinematics/dynamics algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/master/docs/src/algorithms.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#RigidBodyDynamics.DynamicsResult"><code>RigidBodyDynamics.DynamicsResult</code></a></li><li><a href="#RigidBodyDynamics.Spatial.center_of_mass-Tuple{MechanismState}"><code>RigidBodyDynamics.Spatial.center_of_mass</code></a></li><li><a href="#RigidBodyDynamics.Spatial.center_of_mass-Tuple{MechanismState,Any}"><code>RigidBodyDynamics.Spatial.center_of_mass</code></a></li><li><a href="#RigidBodyDynamics._point_jacobian!-Tuple{PointJacobian,MechanismState,RigidBodyDynamics.Graphs.TreePath,Point3D,Any}"><code>RigidBodyDynamics._point_jacobian!</code></a></li><li><a href="#RigidBodyDynamics.default_constraint_stabilization_gains-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>RigidBodyDynamics.default_constraint_stabilization_gains</code></a></li><li><a href="#RigidBodyDynamics.dynamics!-Union{Tuple{X}, Tuple{DynamicsResult,MechanismState{X,M,C,JointCollection} where JointCollection where C where M}, Tuple{DynamicsResult,MechanismState{X,M,C,JointCollection} where JointCollection where C where M,AbstractArray{T,1} where T}, Tuple{DynamicsResult,MechanismState{X,M,C,JointCollection} where JointCollection where C where M,AbstractArray{T,1} where T,AbstractDict{BodyID,var&quot;#s184&quot;} where var&quot;#s184&quot;&lt;:Wrench}} where X"><code>RigidBodyDynamics.dynamics!</code></a></li><li><a href="#RigidBodyDynamics.dynamics!-Union{Tuple{X}, Tuple{StridedArray{X, 1},DynamicsResult,MechanismState{X,M,C,JointCollection} where JointCollection where C where M,AbstractArray{X,1}}, Tuple{StridedArray{X, 1},DynamicsResult,MechanismState{X,M,C,JointCollection} where JointCollection where C where M,AbstractArray{X,1},AbstractArray{T,1} where T}, Tuple{StridedArray{X, 1},DynamicsResult,MechanismState{X,M,C,JointCollection} where JointCollection where C where M,AbstractArray{X,1},AbstractArray{T,1} where T,AbstractDict{BodyID,var&quot;#s185&quot;} where var&quot;#s185&quot;&lt;:Wrench}} where X"><code>RigidBodyDynamics.dynamics!</code></a></li><li><a href="#RigidBodyDynamics.dynamics_bias-Union{Tuple{MechanismState{X,M,C,JointCollection} where JointCollection where C}, Tuple{W}, Tuple{M}, Tuple{X}, Tuple{MechanismState{X,M,C,JointCollection} where JointCollection where C,AbstractDict{BodyID,Wrench{W}}}} where W where M where X"><code>RigidBodyDynamics.dynamics_bias</code></a></li><li><a href="#RigidBodyDynamics.dynamics_bias!-Union{Tuple{X}, Tuple{SegmentedVector{JointID,T,KeyRange,P} where P&lt;:AbstractArray{T,1} where KeyRange&lt;:AbstractRange{JointID} where T,AbstractDict{BodyID,var&quot;#s185&quot;} where var&quot;#s185&quot;&lt;:SpatialAcceleration,AbstractDict{BodyID,var&quot;#s184&quot;} where var&quot;#s184&quot;&lt;:Wrench,MechanismState{X,M,C,JointCollection} where JointCollection where C where M}, Tuple{SegmentedVector{JointID,T,KeyRange,P} where P&lt;:AbstractArray{T,1} where KeyRange&lt;:AbstractRange{JointID} where T,AbstractDict{BodyID,var&quot;#s183&quot;} where var&quot;#s183&quot;&lt;:SpatialAcceleration,AbstractDict{BodyID,var&quot;#s182&quot;} where var&quot;#s182&quot;&lt;:Wrench,MechanismState{X,M,C,JointCollection} where JointCollection where C where M,AbstractDict{BodyID,var&quot;#s17&quot;} where var&quot;#s17&quot;&lt;:Wrench}} where X"><code>RigidBodyDynamics.dynamics_bias!</code></a></li><li><a href="#RigidBodyDynamics.geometric_jacobian-Union{Tuple{C}, Tuple{M}, Tuple{X}, Tuple{MechanismState{X,M,C,JointCollection} where JointCollection,RigidBodyDynamics.Graphs.TreePath{RigidBody{M},Joint{M,JT} where JT&lt;:JointType{M}}}} where C where M where X"><code>RigidBodyDynamics.geometric_jacobian</code></a></li><li><a href="#RigidBodyDynamics.geometric_jacobian!-Tuple{GeometricJacobian,MechanismState,RigidBodyDynamics.Graphs.TreePath,Any}"><code>RigidBodyDynamics.geometric_jacobian!</code></a></li><li><a href="#RigidBodyDynamics.geometric_jacobian!-Tuple{GeometricJacobian,MechanismState,RigidBodyDynamics.Graphs.TreePath,Transform3D}"><code>RigidBodyDynamics.geometric_jacobian!</code></a></li><li><a href="#RigidBodyDynamics.geometric_jacobian!-Tuple{GeometricJacobian,MechanismState,RigidBodyDynamics.Graphs.TreePath}"><code>RigidBodyDynamics.geometric_jacobian!</code></a></li><li><a href="#RigidBodyDynamics.inverse_dynamics-Union{Tuple{W}, Tuple{V}, Tuple{M}, Tuple{X}, Tuple{MechanismState{X,M,C,JointCollection} where JointCollection where C,SegmentedVector{JointID,V,KeyRange,P} where P&lt;:AbstractArray{V,1} where KeyRange&lt;:AbstractRange{JointID}}, Tuple{MechanismState{X,M,C,JointCollection} where JointCollection where C,SegmentedVector{JointID,V,KeyRange,P} where P&lt;:AbstractArray{V,1} where KeyRange&lt;:AbstractRange{JointID},AbstractDict{BodyID,Wrench{W}}}} where W where V where M where X"><code>RigidBodyDynamics.inverse_dynamics</code></a></li><li><a href="#RigidBodyDynamics.inverse_dynamics!-Union{Tuple{T}, Tuple{SegmentedVector{JointID,T,KeyRange,P} where P&lt;:AbstractArray{T,1} where KeyRange&lt;:AbstractRange{JointID} where T,AbstractDict{BodyID,Wrench{T}},AbstractDict{BodyID,SpatialAcceleration{T}},MechanismState,SegmentedVector{JointID,T,KeyRange,P} where P&lt;:AbstractArray{T,1} where KeyRange&lt;:AbstractRange{JointID} where T}, Tuple{SegmentedVector{JointID,T,KeyRange,P} where P&lt;:AbstractArray{T,1} where KeyRange&lt;:AbstractRange{JointID} where T,AbstractDict{BodyID,Wrench{T}},AbstractDict{BodyID,SpatialAcceleration{T}},MechanismState,SegmentedVector{JointID,T,KeyRange,P} where P&lt;:AbstractArray{T,1} where KeyRange&lt;:AbstractRange{JointID} where T,AbstractDict{BodyID,var&quot;#s191&quot;} where var&quot;#s191&quot;&lt;:Wrench}} where T"><code>RigidBodyDynamics.inverse_dynamics!</code></a></li><li><a href="#RigidBodyDynamics.mass-Tuple{Mechanism}"><code>RigidBodyDynamics.mass</code></a></li><li><a href="#RigidBodyDynamics.mass_matrix-Union{Tuple{MechanismState{X,M,C,JointCollection} where JointCollection}, Tuple{C}, Tuple{M}, Tuple{X}} where C where M where X"><code>RigidBodyDynamics.mass_matrix</code></a></li><li><a href="#RigidBodyDynamics.mass_matrix!-Tuple{LinearAlgebra.Symmetric,MechanismState}"><code>RigidBodyDynamics.mass_matrix!</code></a></li><li><a href="#RigidBodyDynamics.momentum_matrix-Tuple{MechanismState}"><code>RigidBodyDynamics.momentum_matrix</code></a></li><li><a href="#RigidBodyDynamics.momentum_matrix!-Tuple{MomentumMatrix,MechanismState,Any}"><code>RigidBodyDynamics.momentum_matrix!</code></a></li><li><a href="#RigidBodyDynamics.momentum_matrix!-Tuple{MomentumMatrix,MechanismState}"><code>RigidBodyDynamics.momentum_matrix!</code></a></li><li><a href="#RigidBodyDynamics.momentum_matrix!-Tuple{MomentumMatrix,MechanismState,Transform3D}"><code>RigidBodyDynamics.momentum_matrix!</code></a></li><li><a href="#RigidBodyDynamics.point_jacobian-Union{Tuple{C}, Tuple{M}, Tuple{X}, Tuple{MechanismState{X,M,C,JointCollection} where JointCollection,RigidBodyDynamics.Graphs.TreePath{RigidBody{M},Joint{M,JT} where JT&lt;:JointType{M}},Point3D}} where C where M where X"><code>RigidBodyDynamics.point_jacobian</code></a></li><li><a href="#RigidBodyDynamics.point_jacobian!-Tuple{PointJacobian,MechanismState,RigidBodyDynamics.Graphs.TreePath,Point3D}"><code>RigidBodyDynamics.point_jacobian!</code></a></li><li><a href="#RigidBodyDynamics.subtree_mass-Union{Tuple{T}, Tuple{RigidBody{T},Mechanism{T}}} where T"><code>RigidBodyDynamics.subtree_mass</code></a></li></ul><h2 id="The-DynamicsResult-type"><a class="docs-heading-anchor" href="#The-DynamicsResult-type">The <code>DynamicsResult</code> type</a><a id="The-DynamicsResult-type-1"></a><a class="docs-heading-anchor-permalink" href="#The-DynamicsResult-type" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.DynamicsResult" href="#RigidBodyDynamics.DynamicsResult"><code>RigidBodyDynamics.DynamicsResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct DynamicsResult{T, M}</code></pre><p>Stores variables related to the dynamics of a <code>Mechanism</code>, e.g. the <code>Mechanism</code>&#39;s mass matrix and joint acceleration vector.</p><p>Type parameters:</p><ul><li><code>T</code>: the scalar type of the dynamics-related variables.</li><li><code>M</code>: the scalar type of the <code>Mechanism</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/dynamics_result.jl#L1">source</a></section></article><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.Spatial.center_of_mass-Tuple{MechanismState,Any}" href="#RigidBodyDynamics.Spatial.center_of_mass-Tuple{MechanismState,Any}"><code>RigidBodyDynamics.Spatial.center_of_mass</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">center_of_mass(state, itr)
</code></pre><p>Compute the center of mass of an iterable subset of a <code>Mechanism</code>&#39;s bodies in the given state. Ignores the root body of the mechanism.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.Spatial.center_of_mass-Tuple{MechanismState}" href="#RigidBodyDynamics.Spatial.center_of_mass-Tuple{MechanismState}"><code>RigidBodyDynamics.Spatial.center_of_mass</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">center_of_mass(state)
</code></pre><p>Compute the center of mass of the whole <code>Mechanism</code> in the given state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics._point_jacobian!-Tuple{PointJacobian,MechanismState,RigidBodyDynamics.Graphs.TreePath,Point3D,Any}" href="#RigidBodyDynamics._point_jacobian!-Tuple{PointJacobian,MechanismState,RigidBodyDynamics.Graphs.TreePath,Point3D,Any}"><code>RigidBodyDynamics._point_jacobian!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_point_jacobian!(Jp, state, path, point, transformfun)
</code></pre><p>Compute the Jacobian mapping the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to the velocity of a point fixed to the target of the joint path (the body succeeding the last joint in the path) with respect to the source of the joint path (the body preceding the first joint in the path).</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L161-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.default_constraint_stabilization_gains-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#RigidBodyDynamics.default_constraint_stabilization_gains-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>RigidBodyDynamics.default_constraint_stabilization_gains</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the default Baumgarte constraint stabilization gains. These gains result in critical damping, and correspond to <span>$T_{stab} = 0.1$</span> in Featherstone (2008), section 8.3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.dynamics!-Union{Tuple{X}, Tuple{DynamicsResult,MechanismState{X,M,C,JointCollection} where JointCollection where C where M}, Tuple{DynamicsResult,MechanismState{X,M,C,JointCollection} where JointCollection where C where M,AbstractArray{T,1} where T}, Tuple{DynamicsResult,MechanismState{X,M,C,JointCollection} where JointCollection where C where M,AbstractArray{T,1} where T,AbstractDict{BodyID,var&quot;#s184&quot;} where var&quot;#s184&quot;&lt;:Wrench}} where X" href="#RigidBodyDynamics.dynamics!-Union{Tuple{X}, Tuple{DynamicsResult,MechanismState{X,M,C,JointCollection} where JointCollection where C where M}, Tuple{DynamicsResult,MechanismState{X,M,C,JointCollection} where JointCollection where C where M,AbstractArray{T,1} where T}, Tuple{DynamicsResult,MechanismState{X,M,C,JointCollection} where JointCollection where C where M,AbstractArray{T,1} where T,AbstractDict{BodyID,var&quot;#s184&quot;} where var&quot;#s184&quot;&lt;:Wrench}} where X"><code>RigidBodyDynamics.dynamics!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dynamics!(result, state)
dynamics!(result, state, torques)
dynamics!(result, state, torques, externalwrenches; stabilization_gains)
</code></pre><p>Compute the joint acceleration vector <span>$\dot{v}$</span> and Lagrange multipliers <span>$\lambda$</span> that satisfy the joint-space equations of motion</p><p class="math-container">\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau - K(q)^{T} \lambda\]</p><p>and the constraint equations</p><p class="math-container">\[K(q) \dot{v} = -k\]</p><p>given joint configuration vector <span>$q$</span>, joint velocity vector <span>$v$</span>, and (optionally) joint torques <span>$\tau$</span> and external wrenches <span>$w_\text{ext}$</span>.</p><p>The <code>externalwrenches</code> argument can be used to specify additional wrenches that act on the <code>Mechanism</code>&#39;s bodies.</p><p>The <code>stabilization_gains</code> keyword argument can be used to set PD gains for Baumgarte stabilization, which can be used to prevent separation of non-tree (loop) joints. See Featherstone (2008), section 8.3 for more information. There are several options for specifying gains:</p><ul><li><code>nothing</code> can be used to completely disable Baumgarte stabilization.</li><li>Gains can be specifed on a per-joint basis using any <code>AbstractDict{JointID, &lt;:RigidBodyDynamics.PDControl.SE3PDGains}</code>, which maps the <code>JointID</code> for the non-tree joints of the mechanism to the gains for that joint.</li><li>As a special case of the second option, the same gains can be used for all joints by passing in a <code>RigidBodyDynamics.CustomCollections.ConstDict{JointID}</code>.</li></ul><p>The <a href="#RigidBodyDynamics.default_constraint_stabilization_gains-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>default_constraint_stabilization_gains</code></a> function is called to produce the default gains, which use the last option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L825-L839">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.dynamics!-Union{Tuple{X}, Tuple{StridedArray{X, 1},DynamicsResult,MechanismState{X,M,C,JointCollection} where JointCollection where C where M,AbstractArray{X,1}}, Tuple{StridedArray{X, 1},DynamicsResult,MechanismState{X,M,C,JointCollection} where JointCollection where C where M,AbstractArray{X,1},AbstractArray{T,1} where T}, Tuple{StridedArray{X, 1},DynamicsResult,MechanismState{X,M,C,JointCollection} where JointCollection where C where M,AbstractArray{X,1},AbstractArray{T,1} where T,AbstractDict{BodyID,var&quot;#s185&quot;} where var&quot;#s185&quot;&lt;:Wrench}} where X" href="#RigidBodyDynamics.dynamics!-Union{Tuple{X}, Tuple{StridedArray{X, 1},DynamicsResult,MechanismState{X,M,C,JointCollection} where JointCollection where C where M,AbstractArray{X,1}}, Tuple{StridedArray{X, 1},DynamicsResult,MechanismState{X,M,C,JointCollection} where JointCollection where C where M,AbstractArray{X,1},AbstractArray{T,1} where T}, Tuple{StridedArray{X, 1},DynamicsResult,MechanismState{X,M,C,JointCollection} where JointCollection where C where M,AbstractArray{X,1},AbstractArray{T,1} where T,AbstractDict{BodyID,var&quot;#s185&quot;} where var&quot;#s185&quot;&lt;:Wrench}} where X"><code>RigidBodyDynamics.dynamics!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dynamics!(ẋ, result, state, x)
dynamics!(ẋ, result, state, x, torques)
dynamics!(ẋ, result, state, x, torques, externalwrenches; stabilization_gains)
</code></pre><p>Convenience function for use with standard ODE integrators that takes a <code>Vector</code> argument</p><p class="math-container">\[x = \left(\begin{array}{c}
q\\
v
\end{array}\right)\]</p><p>and returns a <code>Vector</code> <span>$\dot{x}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L867">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.dynamics_bias!-Union{Tuple{X}, Tuple{SegmentedVector{JointID,T,KeyRange,P} where P&lt;:AbstractArray{T,1} where KeyRange&lt;:AbstractRange{JointID} where T,AbstractDict{BodyID,var&quot;#s185&quot;} where var&quot;#s185&quot;&lt;:SpatialAcceleration,AbstractDict{BodyID,var&quot;#s184&quot;} where var&quot;#s184&quot;&lt;:Wrench,MechanismState{X,M,C,JointCollection} where JointCollection where C where M}, Tuple{SegmentedVector{JointID,T,KeyRange,P} where P&lt;:AbstractArray{T,1} where KeyRange&lt;:AbstractRange{JointID} where T,AbstractDict{BodyID,var&quot;#s183&quot;} where var&quot;#s183&quot;&lt;:SpatialAcceleration,AbstractDict{BodyID,var&quot;#s182&quot;} where var&quot;#s182&quot;&lt;:Wrench,MechanismState{X,M,C,JointCollection} where JointCollection where C where M,AbstractDict{BodyID,var&quot;#s17&quot;} where var&quot;#s17&quot;&lt;:Wrench}} where X" href="#RigidBodyDynamics.dynamics_bias!-Union{Tuple{X}, Tuple{SegmentedVector{JointID,T,KeyRange,P} where P&lt;:AbstractArray{T,1} where KeyRange&lt;:AbstractRange{JointID} where T,AbstractDict{BodyID,var&quot;#s185&quot;} where var&quot;#s185&quot;&lt;:SpatialAcceleration,AbstractDict{BodyID,var&quot;#s184&quot;} where var&quot;#s184&quot;&lt;:Wrench,MechanismState{X,M,C,JointCollection} where JointCollection where C where M}, Tuple{SegmentedVector{JointID,T,KeyRange,P} where P&lt;:AbstractArray{T,1} where KeyRange&lt;:AbstractRange{JointID} where T,AbstractDict{BodyID,var&quot;#s183&quot;} where var&quot;#s183&quot;&lt;:SpatialAcceleration,AbstractDict{BodyID,var&quot;#s182&quot;} where var&quot;#s182&quot;&lt;:Wrench,MechanismState{X,M,C,JointCollection} where JointCollection where C where M,AbstractDict{BodyID,var&quot;#s17&quot;} where var&quot;#s17&quot;&lt;:Wrench}} where X"><code>RigidBodyDynamics.dynamics_bias!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dynamics_bias!(torques, biasaccelerations, wrenches, state)
dynamics_bias!(torques, biasaccelerations, wrenches, state, externalwrenches)
</code></pre><p>Compute the &#39;dynamics bias term&#39;, i.e. the term</p><p class="math-container">\[c(q, v, w_\text{ext})\]</p><p>in the unconstrained joint-space equations of motion</p><p class="math-container">\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau\]</p><p>given joint configuration vector <span>$q$</span>, joint velocity vector <span>$v$</span>, joint acceleration vector <span>$\dot{v}$</span> and (optionally) external wrenches <span>$w_\text{ext}$</span>.</p><p>The <code>externalwrenches</code> argument can be used to specify additional wrenches that act on the <code>Mechanism</code>&#39;s bodies.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L477-L492">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.dynamics_bias-Union{Tuple{MechanismState{X,M,C,JointCollection} where JointCollection where C}, Tuple{W}, Tuple{M}, Tuple{X}, Tuple{MechanismState{X,M,C,JointCollection} where JointCollection where C,AbstractDict{BodyID,Wrench{W}}}} where W where M where X" href="#RigidBodyDynamics.dynamics_bias-Union{Tuple{MechanismState{X,M,C,JointCollection} where JointCollection where C}, Tuple{W}, Tuple{M}, Tuple{X}, Tuple{MechanismState{X,M,C,JointCollection} where JointCollection where C,AbstractDict{BodyID,Wrench{W}}}} where W where M where X"><code>RigidBodyDynamics.dynamics_bias</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dynamics_bias(state)
dynamics_bias(state, externalwrenches)
</code></pre><p>Compute the &#39;dynamics bias term&#39;, i.e. the term</p><p class="math-container">\[c(q, v, w_\text{ext})\]</p><p>in the unconstrained joint-space equations of motion</p><p class="math-container">\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau\]</p><p>given joint configuration vector <span>$q$</span>, joint velocity vector <span>$v$</span>, joint acceleration vector <span>$\dot{v}$</span> and (optionally) external wrenches <span>$w_\text{ext}$</span>.</p><p>The <code>externalwrenches</code> argument can be used to specify additional wrenches that act on the <code>Mechanism</code>&#39;s bodies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L500-L515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.geometric_jacobian!-Tuple{GeometricJacobian,MechanismState,RigidBodyDynamics.Graphs.TreePath,Any}" href="#RigidBodyDynamics.geometric_jacobian!-Tuple{GeometricJacobian,MechanismState,RigidBodyDynamics.Graphs.TreePath,Any}"><code>RigidBodyDynamics.geometric_jacobian!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">geometric_jacobian!(jac, state, path, transformfun)
</code></pre><p>Compute a geometric Jacobian (also known as a basic, or spatial Jacobian) associated with a directed path in the <code>Mechanism</code>&#39;s spanning tree, (a collection of <code>Joint</code>s and traversal directions) in the given state.</p><p>A geometric Jacobian maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to the twist of the target of the joint path (the body succeeding the last joint in the path) with respect to the source of the joint path (the body preceding the first joint in the path).</p><p>See also <a href="../mechanism/#RigidBodyDynamics.path-Tuple{Mechanism,RigidBody,RigidBody}"><code>path</code></a>, <a href="../spatial/#RigidBodyDynamics.Spatial.GeometricJacobian"><code>GeometricJacobian</code></a>, <a href="../spatial/#RigidBodyDynamics.Spatial.Twist"><code>Twist</code></a>.</p><p><code>transformfun</code> is a callable that may be used to transform the individual motion subspaces of each of the joints to the frame in which <code>out</code> is expressed.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L70-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.geometric_jacobian!-Tuple{GeometricJacobian,MechanismState,RigidBodyDynamics.Graphs.TreePath,Transform3D}" href="#RigidBodyDynamics.geometric_jacobian!-Tuple{GeometricJacobian,MechanismState,RigidBodyDynamics.Graphs.TreePath,Transform3D}"><code>RigidBodyDynamics.geometric_jacobian!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">geometric_jacobian!(out, state, path, root_to_desired)
</code></pre><p>Compute a geometric Jacobian (also known as a basic, or spatial Jacobian) associated with a directed path in the <code>Mechanism</code>&#39;s spanning tree, (a collection of <code>Joint</code>s and traversal directions) in the given state.</p><p>A geometric Jacobian maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to the twist of the target of the joint path (the body succeeding the last joint in the path) with respect to the source of the joint path (the body preceding the first joint in the path).</p><p>See also <a href="../mechanism/#RigidBodyDynamics.path-Tuple{Mechanism,RigidBody,RigidBody}"><code>path</code></a>, <a href="../spatial/#RigidBodyDynamics.Spatial.GeometricJacobian"><code>GeometricJacobian</code></a>, <a href="../spatial/#RigidBodyDynamics.Spatial.Twist"><code>Twist</code></a>.</p><p><code>root_to_desired</code> is the transform from the <code>Mechanism</code>&#39;s root frame to the frame in which <code>out</code> is expressed.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L101-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.geometric_jacobian!-Tuple{GeometricJacobian,MechanismState,RigidBodyDynamics.Graphs.TreePath}" href="#RigidBodyDynamics.geometric_jacobian!-Tuple{GeometricJacobian,MechanismState,RigidBodyDynamics.Graphs.TreePath}"><code>RigidBodyDynamics.geometric_jacobian!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">geometric_jacobian!(out, state, path)
</code></pre><p>Compute a geometric Jacobian (also known as a basic, or spatial Jacobian) associated with a directed path in the <code>Mechanism</code>&#39;s spanning tree, (a collection of <code>Joint</code>s and traversal directions) in the given state.</p><p>A geometric Jacobian maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to the twist of the target of the joint path (the body succeeding the last joint in the path) with respect to the source of the joint path (the body preceding the first joint in the path).</p><p>See also <a href="../mechanism/#RigidBodyDynamics.path-Tuple{Mechanism,RigidBody,RigidBody}"><code>path</code></a>, <a href="../spatial/#RigidBodyDynamics.Spatial.GeometricJacobian"><code>GeometricJacobian</code></a>, <a href="../spatial/#RigidBodyDynamics.Spatial.Twist"><code>Twist</code></a>.</p><p>See <a href="#RigidBodyDynamics.geometric_jacobian!-Tuple{GeometricJacobian,MechanismState,RigidBodyDynamics.Graphs.TreePath,Any}"><code>geometric_jacobian!(out, state, path, root_to_desired)</code></a>. Uses <code>state</code> to compute the transform from the <code>Mechanism</code>&#39;s root frame to the frame in which <code>out</code> is expressed.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L115-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.geometric_jacobian-Union{Tuple{C}, Tuple{M}, Tuple{X}, Tuple{MechanismState{X,M,C,JointCollection} where JointCollection,RigidBodyDynamics.Graphs.TreePath{RigidBody{M},Joint{M,JT} where JT&lt;:JointType{M}}}} where C where M where X" href="#RigidBodyDynamics.geometric_jacobian-Union{Tuple{C}, Tuple{M}, Tuple{X}, Tuple{MechanismState{X,M,C,JointCollection} where JointCollection,RigidBodyDynamics.Graphs.TreePath{RigidBody{M},Joint{M,JT} where JT&lt;:JointType{M}}}} where C where M where X"><code>RigidBodyDynamics.geometric_jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">geometric_jacobian(state, path)
</code></pre><p>Compute a geometric Jacobian (also known as a basic, or spatial Jacobian) associated with a directed path in the <code>Mechanism</code>&#39;s spanning tree, (a collection of <code>Joint</code>s and traversal directions) in the given state.</p><p>A geometric Jacobian maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to the twist of the target of the joint path (the body succeeding the last joint in the path) with respect to the source of the joint path (the body preceding the first joint in the path).</p><p>See also <a href="../mechanism/#RigidBodyDynamics.path-Tuple{Mechanism,RigidBody,RigidBody}"><code>path</code></a>, <a href="../spatial/#RigidBodyDynamics.Spatial.GeometricJacobian"><code>GeometricJacobian</code></a>, <a href="../spatial/#RigidBodyDynamics.Spatial.Twist"><code>Twist</code></a>.</p><p>The Jacobian is computed in the <code>Mechanism</code>&#39;s root frame.</p><p>See <a href="#RigidBodyDynamics.geometric_jacobian!-Tuple{GeometricJacobian,MechanismState,RigidBodyDynamics.Graphs.TreePath,Any}"><code>geometric_jacobian!(out, state, path)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L134-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.inverse_dynamics!-Union{Tuple{T}, Tuple{SegmentedVector{JointID,T,KeyRange,P} where P&lt;:AbstractArray{T,1} where KeyRange&lt;:AbstractRange{JointID} where T,AbstractDict{BodyID,Wrench{T}},AbstractDict{BodyID,SpatialAcceleration{T}},MechanismState,SegmentedVector{JointID,T,KeyRange,P} where P&lt;:AbstractArray{T,1} where KeyRange&lt;:AbstractRange{JointID} where T}, Tuple{SegmentedVector{JointID,T,KeyRange,P} where P&lt;:AbstractArray{T,1} where KeyRange&lt;:AbstractRange{JointID} where T,AbstractDict{BodyID,Wrench{T}},AbstractDict{BodyID,SpatialAcceleration{T}},MechanismState,SegmentedVector{JointID,T,KeyRange,P} where P&lt;:AbstractArray{T,1} where KeyRange&lt;:AbstractRange{JointID} where T,AbstractDict{BodyID,var&quot;#s191&quot;} where var&quot;#s191&quot;&lt;:Wrench}} where T" href="#RigidBodyDynamics.inverse_dynamics!-Union{Tuple{T}, Tuple{SegmentedVector{JointID,T,KeyRange,P} where P&lt;:AbstractArray{T,1} where KeyRange&lt;:AbstractRange{JointID} where T,AbstractDict{BodyID,Wrench{T}},AbstractDict{BodyID,SpatialAcceleration{T}},MechanismState,SegmentedVector{JointID,T,KeyRange,P} where P&lt;:AbstractArray{T,1} where KeyRange&lt;:AbstractRange{JointID} where T}, Tuple{SegmentedVector{JointID,T,KeyRange,P} where P&lt;:AbstractArray{T,1} where KeyRange&lt;:AbstractRange{JointID} where T,AbstractDict{BodyID,Wrench{T}},AbstractDict{BodyID,SpatialAcceleration{T}},MechanismState,SegmentedVector{JointID,T,KeyRange,P} where P&lt;:AbstractArray{T,1} where KeyRange&lt;:AbstractRange{JointID} where T,AbstractDict{BodyID,var&quot;#s191&quot;} where var&quot;#s191&quot;&lt;:Wrench}} where T"><code>RigidBodyDynamics.inverse_dynamics!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inverse_dynamics!(torquesout, jointwrenchesout, accelerations, state, v̇)
inverse_dynamics!(torquesout, jointwrenchesout, accelerations, state, v̇, externalwrenches)
</code></pre><p>Do inverse dynamics, i.e. compute <span>$\tau$</span> in the unconstrained joint-space equations of motion</p><p class="math-container">\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau\]</p><p>given joint configuration vector <span>$q$</span>, joint velocity vector <span>$v$</span>, joint acceleration vector <span>$\dot{v}$</span> and (optionally) external wrenches <span>$w_\text{ext}$</span>.</p><p>The <code>externalwrenches</code> argument can be used to specify additional wrenches that act on the <code>Mechanism</code>&#39;s bodies.</p><p>This method implements the recursive Newton-Euler algorithm.</p><p>Currently doesn&#39;t support <code>Mechanism</code>s with cycles.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L535-L551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.inverse_dynamics-Union{Tuple{W}, Tuple{V}, Tuple{M}, Tuple{X}, Tuple{MechanismState{X,M,C,JointCollection} where JointCollection where C,SegmentedVector{JointID,V,KeyRange,P} where P&lt;:AbstractArray{V,1} where KeyRange&lt;:AbstractRange{JointID}}, Tuple{MechanismState{X,M,C,JointCollection} where JointCollection where C,SegmentedVector{JointID,V,KeyRange,P} where P&lt;:AbstractArray{V,1} where KeyRange&lt;:AbstractRange{JointID},AbstractDict{BodyID,Wrench{W}}}} where W where V where M where X" href="#RigidBodyDynamics.inverse_dynamics-Union{Tuple{W}, Tuple{V}, Tuple{M}, Tuple{X}, Tuple{MechanismState{X,M,C,JointCollection} where JointCollection where C,SegmentedVector{JointID,V,KeyRange,P} where P&lt;:AbstractArray{V,1} where KeyRange&lt;:AbstractRange{JointID}}, Tuple{MechanismState{X,M,C,JointCollection} where JointCollection where C,SegmentedVector{JointID,V,KeyRange,P} where P&lt;:AbstractArray{V,1} where KeyRange&lt;:AbstractRange{JointID},AbstractDict{BodyID,Wrench{W}}}} where W where V where M where X"><code>RigidBodyDynamics.inverse_dynamics</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inverse_dynamics(state, v̇)
inverse_dynamics(state, v̇, externalwrenches)
</code></pre><p>Do inverse dynamics, i.e. compute <span>$\tau$</span> in the unconstrained joint-space equations of motion</p><p class="math-container">\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau\]</p><p>given joint configuration vector <span>$q$</span>, joint velocity vector <span>$v$</span>, joint acceleration vector <span>$\dot{v}$</span> and (optionally) external wrenches <span>$w_\text{ext}$</span>.</p><p>The <code>externalwrenches</code> argument can be used to specify additional wrenches that act on the <code>Mechanism</code>&#39;s bodies.</p><p>This method implements the recursive Newton-Euler algorithm.</p><p>Currently doesn&#39;t support <code>Mechanism</code>s with cycles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L555-L571">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.mass-Tuple{Mechanism}" href="#RigidBodyDynamics.mass-Tuple{Mechanism}"><code>RigidBodyDynamics.mass</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mass(m)
</code></pre><p>Return the total mass of the <code>Mechanism</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.mass_matrix!-Tuple{LinearAlgebra.Symmetric,MechanismState}" href="#RigidBodyDynamics.mass_matrix!-Tuple{LinearAlgebra.Symmetric,MechanismState}"><code>RigidBodyDynamics.mass_matrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mass_matrix!(M, state)
</code></pre><p>Compute the joint-space mass matrix (also known as the inertia matrix) of the <code>Mechanism</code> in the given state, i.e., the matrix <span>$M(q)$</span> in the unconstrained joint-space equations of motion</p><p class="math-container">\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau\]</p><p>This method implements the composite rigid body algorithm.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p><p>The <code>out</code> argument must be an <span>$n_v \times n_v$</span> lower triangular <code>Symmetric</code> matrix, where <span>$n_v$</span> is the dimension of the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L237-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.mass_matrix-Union{Tuple{MechanismState{X,M,C,JointCollection} where JointCollection}, Tuple{C}, Tuple{M}, Tuple{X}} where C where M where X" href="#RigidBodyDynamics.mass_matrix-Union{Tuple{MechanismState{X,M,C,JointCollection} where JointCollection}, Tuple{C}, Tuple{M}, Tuple{X}} where C where M where X"><code>RigidBodyDynamics.mass_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the joint-space mass matrix (also known as the inertia matrix) of the <code>Mechanism</code> in the given state, i.e., the matrix <span>$M(q)$</span> in the unconstrained joint-space equations of motion</p><p class="math-container">\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau\]</p><p>This method implements the composite rigid body algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L276-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.momentum_matrix!-Tuple{MomentumMatrix,MechanismState,Any}" href="#RigidBodyDynamics.momentum_matrix!-Tuple{MomentumMatrix,MechanismState,Any}"><code>RigidBodyDynamics.momentum_matrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">momentum_matrix!(mat, state, transformfun)
</code></pre><p>Compute the momentum matrix <span>$A(q)$</span> of the <code>Mechanism</code> in the given state.</p><p>The momentum matrix maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to its total momentum.</p><p>See also <a href="../spatial/#RigidBodyDynamics.Spatial.MomentumMatrix"><code>MomentumMatrix</code></a>.</p><p>The <code>out</code> argument must be a mutable <code>MomentumMatrix</code> with as many columns as the dimension of the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span>.</p><p><code>transformfun</code> is a callable that may be used to transform the individual momentum matrix blocks associated with each of the joints to the frame in which <code>out</code> is expressed.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L302-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.momentum_matrix!-Tuple{MomentumMatrix,MechanismState,Transform3D}" href="#RigidBodyDynamics.momentum_matrix!-Tuple{MomentumMatrix,MechanismState,Transform3D}"><code>RigidBodyDynamics.momentum_matrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">momentum_matrix!(mat, state, root_to_desired)
</code></pre><p>Compute the momentum matrix <span>$A(q)$</span> of the <code>Mechanism</code> in the given state.</p><p>The momentum matrix maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to its total momentum.</p><p>See also <a href="../spatial/#RigidBodyDynamics.Spatial.MomentumMatrix"><code>MomentumMatrix</code></a>.</p><p>The <code>out</code> argument must be a mutable <code>MomentumMatrix</code> with as many columns as the dimension of the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span>.</p><p><code>root_to_desired</code> is the transform from the <code>Mechanism</code>&#39;s root frame to the frame in which <code>out</code> is expressed.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L329-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.momentum_matrix!-Tuple{MomentumMatrix,MechanismState}" href="#RigidBodyDynamics.momentum_matrix!-Tuple{MomentumMatrix,MechanismState}"><code>RigidBodyDynamics.momentum_matrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">momentum_matrix!(out, state)
</code></pre><p>Compute the momentum matrix <span>$A(q)$</span> of the <code>Mechanism</code> in the given state.</p><p>The momentum matrix maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to its total momentum.</p><p>See also <a href="../spatial/#RigidBodyDynamics.Spatial.MomentumMatrix"><code>MomentumMatrix</code></a>.</p><p>The <code>out</code> argument must be a mutable <code>MomentumMatrix</code> with as many columns as the dimension of the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span>.</p><p>See <a href="#RigidBodyDynamics.momentum_matrix!-Tuple{MomentumMatrix,MechanismState,Any}"><code>momentum_matrix!(out, state, root_to_desired)</code></a>. Uses <code>state</code> to compute the transform from the <code>Mechanism</code>&#39;s root frame to the frame in which <code>out</code> is expressed.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L343-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.momentum_matrix-Tuple{MechanismState}" href="#RigidBodyDynamics.momentum_matrix-Tuple{MechanismState}"><code>RigidBodyDynamics.momentum_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">momentum_matrix(state)
</code></pre><p>Compute the momentum matrix <span>$A(q)$</span> of the <code>Mechanism</code> in the given state.</p><p>The momentum matrix maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to its total momentum.</p><p>See also <a href="../spatial/#RigidBodyDynamics.Spatial.MomentumMatrix"><code>MomentumMatrix</code></a>.</p><p>See <a href="#RigidBodyDynamics.momentum_matrix!-Tuple{MomentumMatrix,MechanismState,Any}"><code>momentum_matrix!(out, state)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L362-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.point_jacobian!-Tuple{PointJacobian,MechanismState,RigidBodyDynamics.Graphs.TreePath,Point3D}" href="#RigidBodyDynamics.point_jacobian!-Tuple{PointJacobian,MechanismState,RigidBodyDynamics.Graphs.TreePath,Point3D}"><code>RigidBodyDynamics.point_jacobian!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">point_jacobian!(out, state, path, point)
</code></pre><p>Compute the Jacobian mapping the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to the velocity of a point fixed to the target of the joint path (the body succeeding the last joint in the path) with respect to the source of the joint path (the body preceding the first joint in the path).</p><p>Uses <code>state</code> to compute the transform from the <code>Mechanism</code>&#39;s root frame to the frame in which <code>out</code> is expressed if necessary.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L191-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.point_jacobian-Union{Tuple{C}, Tuple{M}, Tuple{X}, Tuple{MechanismState{X,M,C,JointCollection} where JointCollection,RigidBodyDynamics.Graphs.TreePath{RigidBody{M},Joint{M,JT} where JT&lt;:JointType{M}},Point3D}} where C where M where X" href="#RigidBodyDynamics.point_jacobian-Union{Tuple{C}, Tuple{M}, Tuple{X}, Tuple{MechanismState{X,M,C,JointCollection} where JointCollection,RigidBodyDynamics.Graphs.TreePath{RigidBody{M},Joint{M,JT} where JT&lt;:JointType{M}},Point3D}} where C where M where X"><code>RigidBodyDynamics.point_jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">point_jacobian(state, path, point)
</code></pre><p>Compute the Jacobian mapping the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to the velocity of a point fixed to the target of the joint path (the body succeeding the last joint in the path) with respect to the source of the joint path (the body preceding the first joint in the path).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L213-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RigidBodyDynamics.subtree_mass-Union{Tuple{T}, Tuple{RigidBody{T},Mechanism{T}}} where T" href="#RigidBodyDynamics.subtree_mass-Union{Tuple{T}, Tuple{RigidBody{T},Mechanism{T}}} where T"><code>RigidBodyDynamics.subtree_mass</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">subtree_mass(base, mechanism)
</code></pre><p>Return the mass of a subtree of a <code>Mechanism</code>, rooted at <code>base</code> (including the mass of <code>base</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/04aeaa17bb889588846f831723f212310de95bab/src/mechanism_algorithms.jl#L3">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mechanismstate/">« MechanismState</a><a class="docs-footer-nextpage" href="../customcollections/">Custom collection types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 1 May 2021 15:13">Saturday 1 May 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
