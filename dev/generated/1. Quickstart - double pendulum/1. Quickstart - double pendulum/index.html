<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1. Quickstart - double pendulum · RigidBodyDynamics.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RigidBodyDynamics.jl</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>1. Quickstart - double pendulum</a><ul class="internal"><li><a class="tocitem" href="#Setup"><span>Setup</span></a></li><li><a class="tocitem" href="#Creating-a-double-pendulum-Mechanism"><span>Creating a double pendulum <code>Mechanism</code></span></a></li><li><a class="tocitem" href="#The-state-of-a-Mechanism"><span>The state of a <code>Mechanism</code></span></a></li><li><a class="tocitem" href="#Kinematics"><span>Kinematics</span></a></li><li><a class="tocitem" href="#Dynamics"><span>Dynamics</span></a></li><li><a class="tocitem" href="#Simulation"><span>Simulation</span></a></li></ul></li><li><a class="tocitem" href="../../2. Closed-loop simulation and visualization/2. Closed-loop simulation and visualization/">2. Closed-loop simulation and visualization</a></li><li><a class="tocitem" href="../../3. Four-bar linkage/3. Four-bar linkage/">3. Four-bar linkage</a></li><li><a class="tocitem" href="../../4. Jacobian IK and Control/4. Jacobian IK and Control/">4. Jacobian IK and Control</a></li><li><a class="tocitem" href="../../5. Derivatives and gradients using ForwardDiff/5. Derivatives and gradients using ForwardDiff/">5. Derivatives and gradients using ForwardDiff</a></li><li><a class="tocitem" href="../../6. Symbolics using SymPy/6. Symbolics using SymPy/">6. Symbolics using SymPy</a></li><li><a class="tocitem" href="../../7. Rigorous error bounds using IntervalArithmetic/7. Rigorous error bounds using IntervalArithmetic/">7. Rigorous error bounds using IntervalArithmetic</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../../spatial/">Spatial vector algebra</a></li><li><a class="tocitem" href="../../../joints/">Joints</a></li><li><a class="tocitem" href="../../../rigidbody/">Rigid bodies</a></li><li><a class="tocitem" href="../../../mechanism/">Mechanism</a></li><li><a class="tocitem" href="../../../mechanismstate/">MechanismState</a></li><li><a class="tocitem" href="../../../algorithms/">Kinematics/dynamics algorithms</a></li><li><a class="tocitem" href="../../../customcollections/">Custom collection types</a></li><li><a class="tocitem" href="../../../caches/">Cache types</a></li><li><a class="tocitem" href="../../../simulation/">Simulation</a></li><li><a class="tocitem" href="../../../urdf/">URDF parsing and writing</a></li></ul></li><li><a class="tocitem" href="../../../benchmarks/">Benchmarks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>1. Quickstart - double pendulum</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>1. Quickstart - double pendulum</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/master/examples/1. Quickstart - double pendulum/1. Quickstart - double pendulum.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id=".-Quickstart-double-pendulum"><a class="docs-heading-anchor" href="#.-Quickstart-double-pendulum">1. Quickstart - double pendulum</a><a id=".-Quickstart-double-pendulum-1"></a><a class="docs-heading-anchor-permalink" href="#.-Quickstart-double-pendulum" title="Permalink"></a></h1><p>This example is also available as a Jupyter notebook that can be run locally The notebook can be found in the <code>examples</code> directory of the package. If the notebooks are missing, you may need to run <code>using Pkg; Pkg.build()</code>.</p><h2 id="Setup"><a class="docs-heading-anchor" href="#Setup">Setup</a><a id="Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Setup" title="Permalink"></a></h2><p>In addition to <code>RigidBodyDynamics</code>, we&#39;ll be using the <code>StaticArrays</code> package, used throughout <code>RigidBodyDynamics</code>, which provides stack-allocated, fixed-size arrays:</p><pre><code class="language-julia">using RigidBodyDynamics
using LinearAlgebra
using StaticArrays</code></pre><h2 id="Creating-a-double-pendulum-Mechanism"><a class="docs-heading-anchor" href="#Creating-a-double-pendulum-Mechanism">Creating a double pendulum <code>Mechanism</code></a><a id="Creating-a-double-pendulum-Mechanism-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-double-pendulum-Mechanism" title="Permalink"></a></h2><p>We&#39;re going to create a simple <code>Mechanism</code> that represents a <a href="https://en.wikipedia.org/wiki/Double_pendulum">double pendulum</a>. The <code>Mechanism</code> type can be thought of as an interconnection of rigid bodies and joints.</p><p>We&#39;ll start by creating a &#39;root&#39; rigid body, representing the fixed world, and using it to create a new <code>Mechanism</code>:</p><pre><code class="language-julia">g = -9.81 # gravitational acceleration in z-direction
world = RigidBody{Float64}(&quot;world&quot;)
doublependulum = Mechanism(world; gravity = SVector(0, 0, g))</code></pre><pre class="documenter-example-output">Spanning tree:
Vertex: world (root)
No non-tree joints.</pre><p>Note that the <code>RigidBody</code> type is parameterized on the &#39;scalar type&#39;, here <code>Float64</code>.</p><p>We&#39;ll now add a second body, called &#39;upper link&#39;, to the <code>Mechanism</code>. We&#39;ll attach it to the world with a revolute joint, with the <span>$y$</span>-axis as the axis of rotation. We&#39;ll start by creating a <code>SpatialInertia</code>, which stores the inertial properties of the new body:</p><pre><code class="language-julia">axis = SVector(0., 1., 0.) # joint axis
I_1 = 0.333 # moment of inertia about joint axis
c_1 = -0.5 # center of mass location with respect to joint axis
m_1 = 1. # mass
frame1 = CartesianFrame3D(&quot;upper_link&quot;) # the reference frame in which the spatial inertia will be expressed
inertia1 = SpatialInertia(frame1,
    moment=I_1 * axis * axis&#39;,
    com=SVector(0, 0, c_1),
    mass=m_1)</code></pre><pre class="documenter-example-output">SpatialInertia expressed in &quot;upper_link&quot; (id = 1):
mass: 1.0
center of mass: Point3D in &quot;upper_link&quot;: [0.0, 0.0, -0.5]
moment of inertia (about origin of &quot;upper_link&quot; (id = 1):
[0.0 0.0 0.0; 0.0 0.333 0.0; 0.0 0.0 0.0]</pre><p>Note that the created <code>SpatialInertia</code> is annotated with the frame in which it is expressed (in the form of a <code>CartesianFrame3D</code>). This is a common theme among <code>RigidBodyDynamics</code> objects. Storing frame information with the data obviates the need for the complicated variable naming conventions that are used in some other libraries to disambiguate the frame in which quantities are expressed. It also enables automated reference frame checks.</p><p>We&#39;ll now create the second body:</p><pre><code class="language-julia">upperlink = RigidBody(inertia1)</code></pre><pre class="documenter-example-output">RigidBody: &quot;upper_link&quot;</pre><p>and a new revolute joint called &#39;shoulder&#39;:</p><pre><code class="language-julia">shoulder = Joint(&quot;shoulder&quot;, Revolute(axis))</code></pre><pre class="documenter-example-output">Joint &quot;shoulder&quot;: Revolute joint with axis [0.0, 1.0, 0.0]</pre><p>Creating a <code>Joint</code> automatically constructs two new <code>CartesianFrame3D</code> objects: a frame directly before the joint, and one directly after. To attach the new body to the world by this joint, we&#39;ll have to specify where the frame before the joint is located on the parent body (here, the world):</p><pre><code class="language-julia">before_shoulder_to_world = one(Transform3D,
    frame_before(shoulder), default_frame(world))</code></pre><pre class="documenter-example-output">Transform3D from &quot;before_shoulder&quot; to &quot;world&quot;:
rotation: 0.0 rad about [1.0, 0.0, 0.0], translation: [0.0, 0.0, 0.0]</pre><p>Now we can attach the upper link to the world:</p><pre><code class="language-julia">attach!(doublependulum, world, upperlink, shoulder,
    joint_pose = before_shoulder_to_world)</code></pre><pre class="documenter-example-output">Spanning tree:
Vertex: world (root)
  Vertex: upper_link, Edge: shoulder
No non-tree joints.</pre><p>which changes the tree representation of the <code>Mechanism</code>.</p><p>We can attach the lower link in similar fashion:</p><pre><code class="language-julia">l_1 = -1. # length of the upper link
I_2 = 0.333 # moment of inertia about joint axis
c_2 = -0.5 # center of mass location with respect to joint axis
m_2 = 1. # mass
inertia2 = SpatialInertia(CartesianFrame3D(&quot;lower_link&quot;),
    moment=I_2 * axis * axis&#39;,
    com=SVector(0, 0, c_2),
    mass=m_2)
lowerlink = RigidBody(inertia2)
elbow = Joint(&quot;elbow&quot;, Revolute(axis))
before_elbow_to_after_shoulder = Transform3D(
    frame_before(elbow), frame_after(shoulder), SVector(0, 0, l_1))
attach!(doublependulum, upperlink, lowerlink, elbow,
    joint_pose = before_elbow_to_after_shoulder)</code></pre><pre class="documenter-example-output">Spanning tree:
Vertex: world (root)
  Vertex: upper_link, Edge: shoulder
    Vertex: lower_link, Edge: elbow
No non-tree joints.</pre><p>Now our double pendulum <code>Mechanism</code> is complete.</p><p><strong>Note</strong>: instead of defining the <code>Mechanism</code> in this way, it is also possible to load in a <a href="http://wiki.ros.org/urdf">URDF</a> file (an XML file format used in ROS), using the <code>parse_urdf</code> function, e.g.:</p><pre><code class="language-julia">srcdir = dirname(pathof(RigidBodyDynamics))
urdf = joinpath(srcdir, &quot;..&quot;, &quot;test&quot;, &quot;urdf&quot;, &quot;Acrobot.urdf&quot;)
parse_urdf(urdf)</code></pre><pre class="documenter-example-output">Spanning tree:
Vertex: world (root)
  Vertex: upper_link, Edge: shoulder
    Vertex: lower_link, Edge: elbow
No non-tree joints.</pre><h2 id="The-state-of-a-Mechanism"><a class="docs-heading-anchor" href="#The-state-of-a-Mechanism">The state of a <code>Mechanism</code></a><a id="The-state-of-a-Mechanism-1"></a><a class="docs-heading-anchor-permalink" href="#The-state-of-a-Mechanism" title="Permalink"></a></h2><p>A <code>Mechanism</code> stores the joint/rigid body layout, but no state information. State information is separated out into a <code>MechanismState</code> object:</p><pre><code class="language-julia">state = MechanismState(doublependulum)</code></pre><pre class="documenter-example-output">MechanismState{Float64, Float64, Float64, …}(…)</pre><p>Let&#39;s first set the configurations and velocities of the joints:</p><pre><code class="language-julia">set_configuration!(state, shoulder, 0.3)
set_configuration!(state, elbow, 0.4)
set_velocity!(state, shoulder, 1.)
set_velocity!(state, elbow, 2.);</code></pre><p>The joint configurations and velocities are stored as <code>Vector</code>s (denoted <span>$q$</span> and <span>$v$</span> respectively in this package) inside the <code>MechanismState</code> object:</p><pre><code class="language-julia">q = configuration(state)
v = velocity(state)</code></pre><pre class="documenter-example-output">2-element SegmentedVector{JointID,Float64,Base.OneTo{JointID},Array{Float64,1}}:
 1.0
 2.0</pre><h2 id="Kinematics"><a class="docs-heading-anchor" href="#Kinematics">Kinematics</a><a id="Kinematics-1"></a><a class="docs-heading-anchor-permalink" href="#Kinematics" title="Permalink"></a></h2><p>We are now ready to do kinematics. Here&#39;s how you transform a point at the origin of the frame after the elbow joint to world frame:</p><pre><code class="language-julia">transform(state, Point3D(frame_after(elbow), zero(SVector{3})),
    default_frame(world))</code></pre><pre class="documenter-example-output">Point3D in &quot;world&quot;: [-0.29552020666133955, 0.0, -0.955336489125606]</pre><p>Other objects like <code>Wrench</code>es, <code>Twist</code>s, and <code>SpatialInertia</code>s can be transformed in similar fashion.</p><p>You can also ask for the homogeneous transform to world:</p><pre><code class="language-julia">transform_to_root(state, frame_after(elbow))</code></pre><pre class="documenter-example-output">Transform3D from &quot;after_elbow&quot; to &quot;world&quot;:
rotation: 0.7000000000000001 rad about [7.089183103716176e-63, 1.0, 0.0], translation: [-0.29552020666133955, 0.0, -0.955336489125606]</pre><p>Or a relative transform:</p><pre><code class="language-julia">relative_transform(state, frame_after(elbow), frame_after(shoulder))</code></pre><pre class="documenter-example-output">Transform3D from &quot;after_elbow&quot; to &quot;after_shoulder&quot;:
rotation: 0.39999999999999997 rad about [1.2235735295359127e-62, 1.0, 0.0], translation: [9.370825333944079e-18, 0.0, -0.9999999999999999]</pre><p>and here&#39;s the center of mass of the double pendulum:</p><pre><code class="language-julia">center_of_mass(state)</code></pre><pre class="documenter-example-output">Point3D in &quot;world&quot;: [-0.38269457680542746, 0.0, -0.9077129136653266]</pre><h2 id="Dynamics"><a class="docs-heading-anchor" href="#Dynamics">Dynamics</a><a id="Dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamics" title="Permalink"></a></h2><p>A <code>MechanismState</code> can also be used to compute quantities related to the dynamics of the <code>Mechanism</code>. Here we compute the mass matrix:</p><pre><code class="language-julia">mass_matrix(state)</code></pre><pre class="documenter-example-output">2×2 LinearAlgebra.Symmetric{Float64,Array{Float64,2}}:
 2.58706  0.79353
 0.79353  0.333</pre><p>Note that there is also a zero-allocation version, <code>mass_matrix!</code> (the <code>!</code> at the end of a method is a Julia convention signifying that the function is &#39;in-place&#39;, i.e. modifies its input data).</p><p>We can do inverse dynamics as follows (note again that there is a non-allocating version of this method as well):</p><pre><code class="language-julia">v̇ = similar(velocity(state)) # the joint acceleration vector, i.e., the time derivative of the joint velocity vector v
v̇[shoulder][1] = 1
v̇[elbow][1] = 2
inverse_dynamics(state, v̇)</code></pre><pre class="documenter-example-output">2-element SegmentedVector{JointID,Float64,Base.OneTo{JointID},Array{Float64,1}}:
 10.124916215693656
  4.814127424056643</pre><h2 id="Simulation"><a class="docs-heading-anchor" href="#Simulation">Simulation</a><a id="Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation" title="Permalink"></a></h2><p>Let&#39;s simulate the double pendulum for 5 seconds, starting from the state we defined earlier. For this, we can use the basic <code>simulate</code> function:</p><pre><code class="language-julia">ts, qs, vs = simulate(state, 5., Δt = 1e-3);</code></pre><p><code>simulate</code> returns a vector of times (<code>ts</code>) and associated joint configurations (<code>qs</code>) and velocities (<code>vs</code>). You can of course plot the trajectories using your favorite plotting package (see e.g. <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>). The <a href="https://github.com/JuliaRobotics/MeshCatMechanisms.jl">MeshCatMechanisms</a> or <a href="https://github.com/rdeits/RigidBodyTreeInspector.jl">RigidBodyTreeInspector</a> packages can also be used for 3D animation of the double pendulum in action. See also <a href="https://github.com/JuliaRobotics/RigidBodySim.jl">RigidBodySim.jl</a> for a more full-fledge simulation environment.</p><p>A lower level interface for simulation/ODE integration with more options is also available. Consult the documentation for more information. In addition, <a href="https://github.com/JuliaRobotics/RigidBodySim.jl">RigidBodySim.jl</a> offers a more full-featured simulation environment.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../../">« Home</a><a class="docs-footer-nextpage" href="../../2. Closed-loop simulation and visualization/2. Closed-loop simulation and visualization/">2. Closed-loop simulation and visualization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 1 May 2021 20:05">Saturday 1 May 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
