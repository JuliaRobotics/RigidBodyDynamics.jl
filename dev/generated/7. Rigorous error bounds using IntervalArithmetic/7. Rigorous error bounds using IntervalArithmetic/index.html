<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>7. Rigorous error bounds using IntervalArithmetic · RigidBodyDynamics.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RigidBodyDynamics.jl</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../1. Quickstart - double pendulum/1. Quickstart - double pendulum/">1. Quickstart - double pendulum</a></li><li><a class="tocitem" href="../../2. Closed-loop simulation and visualization/2. Closed-loop simulation and visualization/">2. Closed-loop simulation and visualization</a></li><li><a class="tocitem" href="../../3. Four-bar linkage/3. Four-bar linkage/">3. Four-bar linkage</a></li><li><a class="tocitem" href="../../4. Jacobian IK and Control/4. Jacobian IK and Control/">4. Jacobian IK and Control</a></li><li><a class="tocitem" href="../../5. Derivatives and gradients using ForwardDiff/5. Derivatives and gradients using ForwardDiff/">5. Derivatives and gradients using ForwardDiff</a></li><li><a class="tocitem" href="../../6. Symbolics using SymPy/6. Symbolics using SymPy/">6. Symbolics using SymPy</a></li><li class="is-active"><a class="tocitem" href>7. Rigorous error bounds using IntervalArithmetic</a><ul class="internal"><li><a class="tocitem" href="#Floating-point-error"><span>Floating-point error</span></a></li><li><a class="tocitem" href="#Accuracy-of-RigidBodyDynamics.jl&#39;s-mass_matrix"><span>Accuracy of RigidBodyDynamics.jl&#39;s <code>mass_matrix</code></span></a></li><li><a class="tocitem" href="#Rigorous-(worst-case)-uncertainty-propagation"><span>Rigorous (worst-case) uncertainty propagation</span></a></li></ul></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../../spatial/">Spatial vector algebra</a></li><li><a class="tocitem" href="../../../joints/">Joints</a></li><li><a class="tocitem" href="../../../rigidbody/">Rigid bodies</a></li><li><a class="tocitem" href="../../../mechanism/">Mechanism</a></li><li><a class="tocitem" href="../../../mechanismstate/">MechanismState</a></li><li><a class="tocitem" href="../../../algorithms/">Kinematics/dynamics algorithms</a></li><li><a class="tocitem" href="../../../customcollections/">Custom collection types</a></li><li><a class="tocitem" href="../../../caches/">Cache types</a></li><li><a class="tocitem" href="../../../simulation/">Simulation</a></li><li><a class="tocitem" href="../../../urdf/">URDF parsing and writing</a></li></ul></li><li><a class="tocitem" href="../../../benchmarks/">Benchmarks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>7. Rigorous error bounds using IntervalArithmetic</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>7. Rigorous error bounds using IntervalArithmetic</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/master/examples/7. Rigorous error bounds using IntervalArithmetic/7. Rigorous error bounds using IntervalArithmetic.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id=".-Rigorous-error-bounds-using-IntervalArithmetic"><a class="docs-heading-anchor" href="#.-Rigorous-error-bounds-using-IntervalArithmetic">7. Rigorous error bounds using IntervalArithmetic</a><a id=".-Rigorous-error-bounds-using-IntervalArithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#.-Rigorous-error-bounds-using-IntervalArithmetic" title="Permalink"></a></h1><p>This example is also available as a Jupyter notebook that can be run locally The notebook can be found in the <code>examples</code> directory of the package. If the notebooks are missing, you may need to run <code>using Pkg; Pkg.build()</code>.</p><h2 id="Floating-point-error"><a class="docs-heading-anchor" href="#Floating-point-error">Floating-point error</a><a id="Floating-point-error-1"></a><a class="docs-heading-anchor-permalink" href="#Floating-point-error" title="Permalink"></a></h2><p>In computers, real numbers are commonly approximated using floating-point numbers, such as Julia&#39;s <code>Float64</code>. Unfortunately, not all real numbers can be exactly represented as a finite-size floating-point number, and the results of operations on floating-point numbers can only approximate the results of applying the operation to a true real number. This results in peculiarities like:</p><pre><code class="language-julia">2.6 - 0.7 - 1.9</code></pre><pre class="documenter-example-output">2.220446049250313e-16</pre><p>IntervalArithmetic.jl can be used to quantify floating point error, by computing <em>rigorous</em> worst-case bounds on floating point error, within which the true result is <em>guaranteed</em> to lie.</p><pre><code class="language-julia">using IntervalArithmetic</code></pre><pre class="documenter-example-output"> Activating environment at `~/work/RigidBodyDynamics.jl/RigidBodyDynamics.jl/examples/7. Rigorous error bounds using IntervalArithmetic/Project.toml`</pre><p>IntervalArithmetic.jl provides the <code>Interval</code> type, which stores an upper and a lower bound:</p><pre><code class="language-julia">i = Interval(1.0, 2.0)</code></pre><pre class="documenter-example-output">[1, 2]</pre><pre><code class="language-julia">dump(i)</code></pre><pre class="documenter-example-output">IntervalArithmetic.Interval{Float64}
  lo: Float64 1.0
  hi: Float64 2.0</pre><p>IntervalArithmetic.jl provides overloads for most common Julia functions that take these bounds into account. For example:</p><pre><code class="language-julia">i + i</code></pre><pre class="documenter-example-output">[2, 4]</pre><pre><code class="language-julia">sin(i)</code></pre><pre class="documenter-example-output">[0.84147, 1]</pre><p>Note that the bounds computed by IntervalArithmetic.jl take floating point error into account. Also note that a given real number, once converted to (approximated by) a floating-point number may not be equal to the original real number. To rigorously construct an <code>Interval</code> that contains a given real number as an input, IntervalArithmetic.jl provides the <code>@interval</code> macro:</p><pre><code class="language-julia">i = @interval(2.9)
i.lo === i.hi</code></pre><pre class="documenter-example-output">false</pre><pre><code class="language-julia">dump(i)</code></pre><pre class="documenter-example-output">IntervalArithmetic.Interval{Float64}
  lo: Float64 2.9
  hi: Float64 2.9000000000000004</pre><p>Compare this to</p><pre><code class="language-julia">i = Interval(2.9)
i.lo === i.hi</code></pre><pre class="documenter-example-output">true</pre><pre><code class="language-julia">dump(i)</code></pre><pre class="documenter-example-output">IntervalArithmetic.Interval{Float64}
  lo: Float64 2.9
  hi: Float64 2.9</pre><p>As an example, consider again the peculiar result from before, now using interval arithmetic:</p><pre><code class="language-julia">i = @interval(2.6) - @interval(0.7) - @interval(1.9)</code></pre><pre class="documenter-example-output">[-6.66134e-16, 2.22045e-16]</pre><p>showing that the true result, <code>0</code>, is indeed in the guaranteed interval, and indeed:</p><pre><code class="language-julia">using Test
@test (2.6 - 0.7 - 1.9) ∈ i</code></pre><pre class="documenter-example-output">Test Passed</pre><h2 id="Accuracy-of-RigidBodyDynamics.jl&#39;s-mass_matrix"><a class="docs-heading-anchor" href="#Accuracy-of-RigidBodyDynamics.jl&#39;s-mass_matrix">Accuracy of RigidBodyDynamics.jl&#39;s <code>mass_matrix</code></a><a id="Accuracy-of-RigidBodyDynamics.jl&#39;s-mass_matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Accuracy-of-RigidBodyDynamics.jl&#39;s-mass_matrix" title="Permalink"></a></h2><p>Let&#39;s use IntervalArithmetic.jl to establish rigorous bounds on the accuracy of the accuracy of the <code>mass_matrix</code> algorithm for the Acrobot (double pendulum) in a certain configuration. Let&#39;s get started.</p><pre><code class="language-julia">using RigidBodyDynamics</code></pre><p>We&#39;ll create a <code>Mechanism</code> by parsing the Acrobot URDF, passing in <code>Interval{Float64}</code> as the type used to store the parameters (inertias, link lengths, etc.) of the mechanism. Note that the parameters parsed from the URDF are treated as floating point numbers (i.e., like <code>Interval(2.9)</code> instead of <code>@interval(2.9)</code> above).</p><pre><code class="language-julia">const T = Interval{Float64}
srcdir = dirname(pathof(RigidBodyDynamics))
urdf = joinpath(srcdir, &quot;..&quot;, &quot;test&quot;, &quot;urdf&quot;, &quot;Acrobot.urdf&quot;)
const mechanism = parse_urdf(urdf; scalar_type=T)
state = MechanismState(mechanism)</code></pre><pre class="documenter-example-output">MechanismState{IntervalArithmetic.Interval{Float64}, IntervalArithmetic.Interval{Float64}, IntervalArithmetic.Interval{Float64}, …}(…)</pre><p>Let&#39;s set the initial joint angle of the shoulder joint to the smallest <code>Interval{Float64}</code> containing the real number <span>$1$</span>, and similarly for the elbow joint:</p><pre><code class="language-julia">shoulder, elbow = joints(mechanism)
set_configuration!(state, shoulder, @interval(1))
set_configuration!(state, elbow, @interval(2));</code></pre><p>And now we can compute the mass matrix as normal:</p><pre><code class="language-julia">M = mass_matrix(state)</code></pre><pre class="documenter-example-output">2×2 LinearAlgebra.Symmetric{IntervalArithmetic.Interval{Float64},Array{IntervalArithmetic.Interval{Float64},2}}:
 [1.8307, 1.83071]     [0.913853, 0.913854]
 [0.913853, 0.913854]  [1.32999, 1.33001]</pre><p>Woah, those bounds look pretty big. RigidBodyDynamics.jl must not be very accurate! Actually, things aren&#39;t so bad; the issue is just that IntervalArithmetic.jl isn&#39;t kidding when it comes to guaranteed bounds, and that includes printing the numbers in shortened form. Here are the lengths of the intervals:</p><pre><code class="language-julia">err = map(x -&gt; x.hi - x.lo, M)</code></pre><pre class="documenter-example-output">2×2 Array{Float64,2}:
 3.9968e-15   4.88498e-15
 4.88498e-15  6.43929e-15</pre><pre><code class="language-julia">@test maximum(abs, err) ≈ 0 atol = 1e-14</code></pre><pre class="documenter-example-output">Test Passed</pre><h2 id="Rigorous-(worst-case)-uncertainty-propagation"><a class="docs-heading-anchor" href="#Rigorous-(worst-case)-uncertainty-propagation">Rigorous (worst-case) uncertainty propagation</a><a id="Rigorous-(worst-case)-uncertainty-propagation-1"></a><a class="docs-heading-anchor-permalink" href="#Rigorous-(worst-case)-uncertainty-propagation" title="Permalink"></a></h2><p>IntervalArithmetic.jl can also be applied to propagate uncertainty in a rigorous way when the inputs themselves are uncertain. Consider for example the case that we only know the joint angles up to <span>$\pm 0.05$</span> radians:</p><pre><code class="language-julia">set_configuration!(state, shoulder, @interval(0.95, 1.05))
set_configuration!(state, elbow, @interval(1.95, 2.05));</code></pre><p>and let&#39;s compute bounds on the center of mass position:</p><pre><code class="language-julia">center_of_mass(state)</code></pre><pre class="documenter-example-output">Point3D in &quot;world&quot;: IntervalArithmetic.Interval{Float64}[[-0.770193, -0.630851], [0.199999, 0.200001], [0.0167304, 0.163822]]</pre><p>Note that the bounds on the <span>$y$</span>-coordinate are very tight, since our mechanism only lives in the <span>$x$</span>-<span>$z$</span> plane.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../6. Symbolics using SymPy/6. Symbolics using SymPy/">« 6. Symbolics using SymPy</a><a class="docs-footer-nextpage" href="../../../spatial/">Spatial vector algebra »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 1 May 2021 20:05">Saturday 1 May 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
