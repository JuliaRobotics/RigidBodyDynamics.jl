<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>5. Derivatives and gradients using ForwardDiff · RigidBodyDynamics.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RigidBodyDynamics.jl</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../1. Quickstart - double pendulum/1. Quickstart - double pendulum/">1. Quickstart - double pendulum</a></li><li><a class="tocitem" href="../../2. Closed-loop simulation and visualization/2. Closed-loop simulation and visualization/">2. Closed-loop simulation and visualization</a></li><li><a class="tocitem" href="../../3. Four-bar linkage/3. Four-bar linkage/">3. Four-bar linkage</a></li><li><a class="tocitem" href="../../4. Jacobian IK and Control/4. Jacobian IK and Control/">4. Jacobian IK and Control</a></li><li class="is-active"><a class="tocitem" href>5. Derivatives and gradients using ForwardDiff</a><ul class="internal"><li><a class="tocitem" href="#Setup"><span>Setup</span></a></li><li><a class="tocitem" href="#Jacobians-with-respect-to-q-and-v-the-naive-way"><span>Jacobians with respect to <span>$q$</span> and <span>$v$</span> - the naive way</span></a></li><li><a class="tocitem" href="#Improving-performance"><span>Improving performance</span></a></li><li><a class="tocitem" href="#Time-derivatives"><span>Time derivatives</span></a></li></ul></li><li><a class="tocitem" href="../../6. Symbolics using SymPy/6. Symbolics using SymPy/">6. Symbolics using SymPy</a></li><li><a class="tocitem" href="../../7. Rigorous error bounds using IntervalArithmetic/7. Rigorous error bounds using IntervalArithmetic/">7. Rigorous error bounds using IntervalArithmetic</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../../spatial/">Spatial vector algebra</a></li><li><a class="tocitem" href="../../../joints/">Joints</a></li><li><a class="tocitem" href="../../../rigidbody/">Rigid bodies</a></li><li><a class="tocitem" href="../../../mechanism/">Mechanism</a></li><li><a class="tocitem" href="../../../mechanismstate/">MechanismState</a></li><li><a class="tocitem" href="../../../algorithms/">Kinematics/dynamics algorithms</a></li><li><a class="tocitem" href="../../../customcollections/">Custom collection types</a></li><li><a class="tocitem" href="../../../caches/">Cache types</a></li><li><a class="tocitem" href="../../../simulation/">Simulation</a></li><li><a class="tocitem" href="../../../urdf/">URDF parsing and writing</a></li></ul></li><li><a class="tocitem" href="../../../benchmarks/">Benchmarks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>5. Derivatives and gradients using ForwardDiff</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>5. Derivatives and gradients using ForwardDiff</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/master/examples/5. Derivatives and gradients using ForwardDiff/5. Derivatives and gradients using ForwardDiff.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id=".-Derivatives-and-gradients-using-ForwardDiff"><a class="docs-heading-anchor" href="#.-Derivatives-and-gradients-using-ForwardDiff">5. Derivatives and gradients using ForwardDiff</a><a id=".-Derivatives-and-gradients-using-ForwardDiff-1"></a><a class="docs-heading-anchor-permalink" href="#.-Derivatives-and-gradients-using-ForwardDiff" title="Permalink"></a></h1><p>This example is also available as a Jupyter notebook that can be run locally The notebook can be found in the <code>examples</code> directory of the package. If the notebooks are missing, you may need to run <code>using Pkg; Pkg.build()</code>.</p><h2 id="Setup"><a class="docs-heading-anchor" href="#Setup">Setup</a><a id="Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Setup" title="Permalink"></a></h2><pre><code class="language-julia">using RigidBodyDynamics, StaticArrays, ForwardDiff
using Test, Random
Random.seed!(1); # to get repeatable results</code></pre><pre class="documenter-example-output"> Activating environment at `~/work/RigidBodyDynamics.jl/RigidBodyDynamics.jl/examples/5. Derivatives and gradients using ForwardDiff/Project.toml`</pre><h2 id="Jacobians-with-respect-to-q-and-v-the-naive-way"><a class="docs-heading-anchor" href="#Jacobians-with-respect-to-q-and-v-the-naive-way">Jacobians with respect to <span>$q$</span> and <span>$v$</span> - the naive way</a><a id="Jacobians-with-respect-to-q-and-v-the-naive-way-1"></a><a class="docs-heading-anchor-permalink" href="#Jacobians-with-respect-to-q-and-v-the-naive-way" title="Permalink"></a></h2><p>First, we&#39;ll load our trusty double pendulum from a URDF:</p><pre><code class="language-julia">srcdir = dirname(pathof(RigidBodyDynamics))
urdf = joinpath(srcdir, &quot;..&quot;, &quot;test&quot;, &quot;urdf&quot;, &quot;Acrobot.urdf&quot;)
mechanism = parse_urdf(urdf)</code></pre><pre class="documenter-example-output">Spanning tree:
Vertex: world (root)
  Vertex: upper_link, Edge: shoulder
    Vertex: lower_link, Edge: elbow
No non-tree joints.</pre><p>Of course, we can create a <code>MechanismState</code> for the double pendulum, and compute its momentum in some random state:</p><pre><code class="language-julia">float64state = MechanismState(mechanism)
rand!(float64state)
momentum(float64state)</code></pre><pre class="documenter-example-output">Momentum expressed in &quot;world&quot;:
angular: [0.0801508429099656, 1.4308383504250024, 0.15951325559917823], linear: [-0.6978510021979175, 0.0, 0.33892351174664365]</pre><p>But now suppose we want the Jacobian of momentum with respect to the joint velocity vector <span>$v$</span>. We can do this using the <code>ForwardDiff.Dual</code> type and the <code>ForwardDiff.jacobian</code> function. The ForwardDiff package implements forward-mode <a href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a>.</p><p>To use <code>ForwardDiff.jacobian</code> we&#39;ll create a function that maps <code>v</code> (as a <code>Vector</code>) to momentum (as a <code>Vector</code>):</p><pre><code class="language-julia">q = configuration(float64state)
function momentum_vec(v::AbstractVector{T}) where T
    # create a `MechanismState` that can handle the element type of `v` (which will be some `ForwardDiff.Dual`):
    state = MechanismState{T}(mechanism)

    # set the state variables:
    set_configuration!(state, q)
    set_velocity!(state, v)

    # return momentum converted to an `SVector` (as ForwardDiff expects an `AbstractVector`)
    Vector(SVector(momentum(state)))
end</code></pre><pre class="documenter-example-output">momentum_vec (generic function with 1 method)</pre><p>Let&#39;s first check that the function returns the same thing we got from <code>float64state</code>:</p><pre><code class="language-julia">v = velocity(float64state)
@test momentum_vec(v) == SVector(momentum(float64state))</code></pre><pre class="documenter-example-output">Test Passed</pre><p>That works, so now let&#39;s compute the Jacobian with <code>ForwardDiff</code>:</p><pre><code class="language-julia">J = ForwardDiff.jacobian(momentum_vec, v)</code></pre><pre class="documenter-example-output">6×2 Array{Float64,2}:
  0.252338   0.157137
  4.51855    2.25777
  0.505187   0.194443
 -2.21197   -0.777771
  0.0        0.0
  1.06794    0.628547</pre><p>At this point we note that the matrix <code>J</code> is simply the momentum matrix (in world frame) of the <code>Mechanism</code>. In this case, RigidBodyDynamics.jl has a specialized algorithm for computing this matrix, so let&#39;s verify the results:</p><pre><code class="language-julia">A = momentum_matrix(float64state)
@test J ≈ Array(A) atol = 1e-12</code></pre><pre class="documenter-example-output">Test Passed</pre><p>Gradients with respect to <span>$q$</span> can be computed in similar fashion.</p><h2 id="Improving-performance"><a class="docs-heading-anchor" href="#Improving-performance">Improving performance</a><a id="Improving-performance-1"></a><a class="docs-heading-anchor-permalink" href="#Improving-performance" title="Permalink"></a></h2><p>Ignoring the fact that we have a specialized method available, let&#39;s look at the performance of using <code>ForwardDiff.jacobian</code>.</p><pre><code class="language-julia">using BenchmarkTools
@benchmark ForwardDiff.jacobian($momentum_vec, $v)</code></pre><pre class="documenter-example-output">BenchmarkTools.Trial: 
  memory estimate:  39.25 KiB
  allocs estimate:  417
  --------------
  minimum time:     77.500 μs (0.00% GC)
  median time:      90.600 μs (0.00% GC)
  mean time:        106.402 μs (7.30% GC)
  maximum time:     20.377 ms (98.43% GC)
  --------------
  samples:          10000
  evals/sample:     1</pre><p>That&#39;s not great. Note all the allocations. We can do better by making the following modifications:</p><ol><li>use an in-place version of the <code>jacobian</code> function, <code>ForwardDiff.jacobian!</code></li><li>reimplement our <code>momentum_vec</code> function to be in-place as well</li><li>don&#39;t create a new <code>MechanismState</code> every time</li></ol><p>The third point is especially important; creating a <code>MechanismState</code> is expensive!</p><p>Regarding the second point, we could also just stop converting momentum from a <code>StaticArrays.SVector</code> to a <code>Vector</code> to avoid allocations. However, the solution of making the function in-place also applies when the size of the output vector is not known statically (e.g., for <code>dynamics_bias!</code>).</p><p>To facillitate reuse of <code>MechanismState</code>s while keeping the code nice and generic, we can use a <code>StateCache</code> object. <code>StateCache</code> is a container that stores <code>MechanismState</code>s of various types (associated with one <code>Mechanism</code>), and will ease the process of using <code>ForwardDiff</code>. Creating one is easy:</p><pre><code class="language-julia">const statecache = StateCache(mechanism)</code></pre><pre class="documenter-example-output">StateCache{…}(…)</pre><p><code>MechanismState</code>s of a given type can be accessed as follows (note that if a <code>MechanismState</code> of a certain type is already available, it will be reused):</p><pre><code class="language-julia">float32state = statecache[Float32]
@test float32state === statecache[Float32]</code></pre><pre class="documenter-example-output">Test Passed</pre><p>Now we&#39;ll use the <code>StateCache</code> to reimplement <code>momentum_vec</code>, making it in-place as well:</p><pre><code class="language-julia">function momentum_vec!(out::AbstractVector, v::AbstractVector{T}) where T
    # retrieve a `MechanismState` that can handle the element type of `v`:
    state = statecache[T]

    # set the state variables:
    set_configuration!(state, q)
    set_velocity!(state, v)

    # compute momentum and store it in `out`
    m = momentum(state)
    copyto!(out, SVector(m))
end</code></pre><pre class="documenter-example-output">momentum_vec! (generic function with 1 method)</pre><p>Check that the in-place version works as expected on <code>Float64</code> inputs:</p><pre><code class="language-julia">const out = zeros(6) # where we&#39;ll be storing our results
momentum_vec!(out, v)
@test out == SVector(momentum(float64state))</code></pre><pre class="documenter-example-output">Test Passed</pre><p>And use <code>ForwardDiff.jacobian!</code> to compute the Jacobian:</p><pre><code class="language-julia">const result = DiffResults.JacobianResult(out, v)
const config = ForwardDiff.JacobianConfig(momentum_vec!, out, v)
ForwardDiff.jacobian!(result, momentum_vec!, out, v, config)
J = DiffResults.jacobian(result)
@test J ≈ Array(A) atol = 1e-12</code></pre><pre class="documenter-example-output">Test Passed</pre><p>Let&#39;s check the performance again:</p><pre><code class="language-julia">@benchmark ForwardDiff.jacobian!($result, $momentum_vec!, $out, $v, $config)</code></pre><pre class="documenter-example-output">BenchmarkTools.Trial: 
  memory estimate:  0 bytes
  allocs estimate:  0
  --------------
  minimum time:     1.160 μs (0.00% GC)
  median time:      1.180 μs (0.00% GC)
  mean time:        1.285 μs (0.00% GC)
  maximum time:     20.430 μs (0.00% GC)
  --------------
  samples:          10000
  evals/sample:     10</pre><p>That&#39;s much better. Do note that the specialized algorithm is still faster:</p><pre><code class="language-julia">q = copy(configuration(float64state))
@benchmark begin
    set_configuration!($float64state, $q)
    momentum_matrix!($A, $float64state)
end</code></pre><pre class="documenter-example-output">BenchmarkTools.Trial: 
  memory estimate:  0 bytes
  allocs estimate:  0
  --------------
  minimum time:     444.444 ns (0.00% GC)
  median time:      482.828 ns (0.00% GC)
  mean time:        510.098 ns (0.00% GC)
  maximum time:     13.358 μs (0.00% GC)
  --------------
  samples:          10000
  evals/sample:     198</pre><h2 id="Time-derivatives"><a class="docs-heading-anchor" href="#Time-derivatives">Time derivatives</a><a id="Time-derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Time-derivatives" title="Permalink"></a></h2><p>We can also use ForwardDiff to compute time derivatives. Let&#39;s verify that energy is conserved for the double pendulum in the absence of nonconservative forces (like damping). That is, we expect that the time derivative of the pendulum&#39;s total energy is zero when its state evolves according to the passive dynamics.</p><p>Let&#39;s first compute the joint acceleration vector <span>$\dot{v}$</span> using the passive dynamics:</p><pre><code class="language-julia">dynamicsresult = DynamicsResult(mechanism)
set_configuration!(float64state, q)
set_velocity!(float64state, v)
dynamics!(dynamicsresult, float64state)
v̇ = dynamicsresult.v̇</code></pre><pre class="documenter-example-output">2-element SegmentedVector{JointID,Float64,Base.OneTo{JointID},Array{Float64,1}}:
  0.07968076794580554
 -4.7988253599776085</pre><p>Now for the time derivative of total energy. ForwardDiff has a <code>derivative</code> function that can be used to take derivatives of functions that map a scalar to a scalar. But in this example, we&#39;ll instead use ForwardDiff&#39;s <code>Dual</code> type directly. <code>ForwardDiff.Dual</code> represents a (potentially multidimensional) dual number, i.e., a type that stores both the value of a function evaluated at a certain point, as well as the partial derivatives of the function, again evaluated at the same point. See the <a href="http://www.juliadiff.org/ForwardDiff.jl/stable/dev/how_it_works.html">ForwardDiff documentation</a> for more information.</p><p>We&#39;ll create a vector of <code>Dual</code>s representing the value and derivative of <span>$q(t)$</span>:</p><pre><code class="language-julia">q̇ = v
q_dual = ForwardDiff.Dual.(q, q̇)</code></pre><pre class="documenter-example-output">2-element Array{ForwardDiff.Dual{Nothing,Float64,1},1}:
 Dual{Nothing}(0.2972879845354616,0.3127069683360675)
 Dual{Nothing}(0.3823959677906078,0.00790928339056074)</pre><p><strong>Note</strong>: for the double pendulum, <span>$\dot{q} = v$</span>, but this is not the case in general for <code>Mechanism</code>s created using RigidBodyDynamics.jl. For example, the <code>QuaternionSpherical</code> joint type uses a unit quaternion to represent the joint configuration, but angular velocity (in body frame) to represent velocity. In general <span>$\dot{q}$</span> can be computed from the velocity vector <span>$v$</span> stored in a <code>MechanismState</code> using</p><pre><code class="language-julia">configuration_derivative(::MechanismState)</code></pre><p>or its in-place variant, <code>configuration_derivative!</code>.</p><p>We&#39;ll do the same thing for <span>$v(t)$</span>:</p><pre><code class="language-julia">v_dual = ForwardDiff.Dual.(v, v̇)</code></pre><pre class="documenter-example-output">2-element Array{ForwardDiff.Dual{Nothing,Float64,1},1}:
 Dual{Nothing}(0.3127069683360675,0.07968076794580554)
 Dual{Nothing}(0.00790928339056074,-4.7988253599776085)</pre><p>Now we&#39;re ready to compute the total energy (kinetic + potential) using these <code>ForwardDiff.Dual</code> inputs. We&#39;ll use our <code>StateCache</code> again:</p><pre><code class="language-julia">T = eltype(q_dual)
state = statecache[T]
set_configuration!(state, q_dual)
set_velocity!(state, v_dual)
energy_dual = kinetic_energy(state) + gravitational_potential_energy(state)</code></pre><pre class="documenter-example-output">Dual{Nothing}(-21.472905435008563,4.440892098500626e-16)</pre><p>Note that the result type of <code>energy_dual</code> is again a <code>ForwardDiff.Dual</code>. We can extract the energy and its time derivative (mechanical power) from <code>energy_dual</code> as follows:</p><pre><code class="language-julia">energy = ForwardDiff.value(energy_dual)
partials = ForwardDiff.partials(energy_dual)
power = partials[1];</code></pre><p>So the total energy in the system is:</p><pre><code class="language-julia">energy</code></pre><pre class="documenter-example-output">-21.472905435008563</pre><p><strong>Note</strong>: the total energy is negative because the origin of the world frame is used as a reference for computing gravitational potential energy, i.e., the center of mass of the double pendulum is somewhere below this origin.</p><p>And we can verify that, indeed, there is no power flow into or out of the system:</p><pre><code class="language-julia">@test power ≈ 0 atol = 1e-14</code></pre><pre class="documenter-example-output">Test Passed</pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../4. Jacobian IK and Control/4. Jacobian IK and Control/">« 4. Jacobian IK and Control</a><a class="docs-footer-nextpage" href="../../6. Symbolics using SymPy/6. Symbolics using SymPy/">6. Symbolics using SymPy »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 1 May 2021 14:55">Saturday 1 May 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
